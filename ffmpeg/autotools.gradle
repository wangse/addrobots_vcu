/*
  BSD License
 		Copyright (c) 2016, Jeff Williams
 		All rights reserved.

 		Redistribution and use in source and binary forms, with or without
 		modification, are permitted provided that the following conditions are met:
 		* Redistributions of source code must retain the above copyright
 		notice, this list of conditions and the following disclaimer.
 		* Redistributions in binary form must reproduce the above copyright
 		notice, this list of conditions and the following disclaimer in the
 		documentation and/or other materials provided with the distribution.
 		* Neither the name of the <organization> nor the
 		names of its contributors may be used to endorse or promote products
 		derived from this software without specific prior written permission.

 		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 		ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 		WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 		DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 		DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 		(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 		LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 		ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 		(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 		SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */

apply plugin: 'com.android.model.library'

import java.util.regex.Matcher
import org.gradle.internal.os.OperatingSystem
import org.apache.tools.ant.types.Commandline

def createConfigureTask(abiType, mode) {
	logger.info("************************************************************************")
	logger.info("Create config task: " + abiType)
	return tasks.create("configure_${abiType}_${mode}", Task) {
		def setupBuildDir = "../../ffmpeg/build_" + abiType
		inputs.file file("../../ffmpeg/RELEASE")
		inputs.property "CONFIGURE_FLAGS", CONFIGURE_FLAGS
		outputs.file file("${setupBuildDir}/config.h")
		doLast {
			configure(abiType, setupBuildDir)
		}
	}
}

def createSetupSourcesTask(abiType, mode, libBinaries) {
	logger.info("************************************************************************")
	logger.info("Create setup task: " + abiType)
	return tasks.create("setup_${abiType}_${mode}", Task) {
		doLast {
			logger.info("************************************************************************")
			logger.info("Setup compiler sources: " + abiType)
			String libraryName = "ffmpeg" + abiType.capitalize() + mode.capitalize() + "SharedLibrary"
			logger.info("Library: " + libraryName)
			logger.info("Binaries: " + libBinaries.get(libraryName).sources.mainC.source.class)
			def sourceSet = libBinaries.get(libraryName).sources.mainC
			if (sourceSet != null) {
				setPropsFromConfigH(abiType)
				// Zero out the includes so that we only use the set from the gradle.properties file.
				Set<String> cFileSet = new HashSet<String>();
				//sourceSet.source.setIncludes(cFileMap)
				logger.info("Source set class: " + sourceSet.class)
				logger.info("Source class: " + sourceSet.source.class)

				def sourceAbiType = abiType
				if (abiType.equals('x86_64')) {
					sourceAbiType = 'x86'
				}
				extractSourcesFromMakefile(cFileSet, "libavcodec", "Makefile")
				//extractSourcesFromMakefile(cFileSet, "libavcodec/${getConfigArch(sourceAbiType)}", "Makefile")
				extractSourcesFromMakefile(cFileSet, "libavutil", "Makefile")
				//extractSourcesFromMakefile(cFileSet, "libavutil/${getConfigArch(sourceAbiType)}", "Makefile")
				extractSourcesFromMakefile(cFileSet, "libswresample", "Makefile")
				//extractSourcesFromMakefile(cFileSet, "libswresample/${getConfigArch(sourceAbiType)}", "Makefile")
				extractSourcesFromMakefile(cFileSet, "libswscale", "Makefile")
				if (!(abiType =~ /mips/)) {
					//extractSourcesFromMakefile(cFileSet, "libswscale/${getConfigArch(sourceAbiType)}", "Makefile")
				}

				// Add the set members to the SourceSet includes.
				cFileSet.each { path ->
					if (!file("../../ffmpeg/build_${abiType}/${path}").exists()) {
						// If the file doesn't exist, it might be an assembly (.S, .asm)
						logger.debug("Not found: ../../ffmpeg/build_${abiType}/${path}")
						path = path.replaceAll(/\.c/, '.S')
						if (!file("../../ffmpeg/build_${abiType}/${path}").exists()) {
							logger.debug("Not found: ../../ffmpeg/build_${abiType}/${path}")
							path = path.replaceAll(/\.S/, '.asm')
						}
					}

					if ((path.contains("src/libavcodec/log2_tab.c"))
							|| (path.contains("src/libavformat/log2_tab.c"))
							|| (path.contains("src/libswresample/log2_tab.c"))
							|| (path.contains("src/libswscale/log2_tab.c"))
							|| (path.contains("src/libavcodec/reverse.c"))) {

					} else {
						logger.debug("Add: " + path)
						sourceSet.source.include "${path}"
					}
				}
				sourceSet.source.srcDir "../../ffmpeg/build_" + abiType
//			inputs.property "SOURCE_COUNT", cFileSet.size()
			}
		}
	}
}

def extractSourcesFromMakefile(Set<String> cFileSet, path, makefileName) {
	File makefile = new File("../ffmpeg/${path}/${makefileName}")
	String multiLine
	def regex = /\\$/
	makefile.getText('UTF-8').eachLine { line ->
		multiLine += line.replaceAll(regex, '').trim() + " "
		if (!(line =~ regex)) {
			if (multiLine =~ /\.o/) {
				List<String> tokens = multiLine.split(/[+]*=/)
				if (tokens.size() > 1) {
					def files = null
					if (tokens[0] =~ /OBJS\-\$\((.*)\)/) {
						if (System.getProperty(Matcher.lastMatcher[0][1]).equals("1")) {
							logger.debug("Property set: " + tokens[0]) + " add:" + tokens[1]
							files = tokens[1]
						} else {
							logger.debug("Property not set: " + tokens[0]) + " skip:" + tokens[1]
						}
					} else if (tokens[0] =~ /OBJS/) {
						files = tokens[1]
					}
					if (files != null) {
						files.tokenize(' ').each { file ->
							file = file.replaceAll(/\.o/, '.c').trim()
							if (file =~ /\/(.+\.c)/) {
								file = Matcher.lastMatcher[0][1]
							}
							logger.debug("Extract: " + file)
							cFileSet.add("src/${path}/${file}")
						}
					}
				}
			}
			multiLine = ""
		}
	}
}

def configure(abiType, setupBuildDir) {
	logger.info("************************************************************************")
	logger.info("Configure - Architecture: " + abiType)

	String extraCFlags = System.getProperty("CONFIG_CFLAGS_" + abiType.toUpperCase()) ?: ""

	String MOD_CONFIGURE_FLAGS = CONFIGURE_FLAGS.replaceAll("PREBUILT", getPrebuiltDir(abiType))
	MOD_CONFIGURE_FLAGS = MOD_CONFIGURE_FLAGS.replaceAll("PLATFORM", getPlatformDir(abiType))
	MOD_CONFIGURE_FLAGS = MOD_CONFIGURE_FLAGS.replaceAll("EXTRA_CFLAGS", extraCFlags)
	MOD_CONFIGURE_FLAGS = MOD_CONFIGURE_FLAGS.replaceAll("ARCH", getToolchainPrefix(abiType))
	MOD_CONFIGURE_FLAGS = MOD_CONFIGURE_FLAGS.replaceAll("ABI", getConfigArch(abiType))

	exec {
		commandLine "mkdir", "-p", "${setupBuildDir}"
	}
	exec {
		workingDir "${setupBuildDir}"
		commandLine "../configure"
		List<String> argStr = Commandline.translateCommandline(MOD_CONFIGURE_FLAGS)
		setArgs(argStr)
		logger.info("cmd: " + commandLine)
	}
	exec {
		// We have to make ffversion.h
		workingDir "${setupBuildDir}"
		commandLine "make", "libavutil/ffversion.h"
	}
	logger.info("************************************************************************")
}

// Hey Google, all of these directory definitions should be System.properties.
// The plugin and NDK already know this stuff - just expose it to us.

def getNdkDir() {
	if (System.env.ANDROID_NDK_ROOT != null)
		return System.env.ANDROID_NDK_ROOT

	Properties properties = new Properties()
	properties.load(project.rootProject.file('local.properties').newDataInputStream())
	def ndkdir = properties.getProperty('ndk.dir', null)
	if (ndkdir == null)
		throw new GradleException("""\
                NDK location not found.
                Define location with ndk.dir in the local.properties file
                or with an ANDROID_NDK_ROOT environment variable.""")

	return ndkdir
}

def getToolchainName(abi) {
	switch (abi) {
		case ~/^armeabi.*/:
			return "arm-linux-androideabi"
		case ~/^arm64.*/:
			return "aarch64-linux-android"
		case "mips":
			return "mipsel-linux-android"
		case "mips64":
			return "mips64el-linux-android"
		case "x86":
			return "x86"
		case "x86_64":
			return "x86_64"
		default:
			throw new GradleException("Unsupported ABI: '${abi}'")
	}
}

def getPlatformName(abi) {
	switch (abi) {
		case ~/^armeabi.*/:
			return "arch-arm"
		case ~/^arm64.*/:
			return "arch-arm64"
		case "mips":
			return "arch-mips"
		case "mips64":
			return "arch-mips64"
		case "x86":
			return "arch-x86"
		case "x86_64":
			return "arch-x86_64"
		default:
			throw new GradleException("Unsupported ABI: '${abi}'")
	}
}

def getConfigArch(abi) {
	switch (abi) {
		case ~/^armeabi.*/:
			return "arm"
		case ~/^arm64.*/:
			return "aarch64"
		case "mips":
			return "mips"
		case "mips64":
			return "mips64"
		case "x86":
			return "x86"
		case "x86_64":
			return "x86_64"
		default:
			throw new GradleException("Unsupported ABI: '${abi}'")
	}
}

def getToolchainPrefix(abi) {
	switch (abi) {
		case ~/^armeabi.*/:
			return "arm-linux-androideabi"
		case ~/^arm64.*/:
			return "aarch64-linux-android"
		case "mips":
			return "mipsel-linux-android"
		case "mips64":
			return "mips64el-linux-android"
		case "x86":
			return "i686-linux-android"
		case "x86_64":
			return "x86_64-linux-android"
		default:
			throw new GradleException("Unsupported ABI: '${abi}'")
	}
}

def getHostOS() {
	if (org.gradle.internal.os.OperatingSystem.current().isLinux())
		return "linux"
	if (org.gradle.internal.os.OperatingSystem.current().isMacOsX())
		return "darwin"
	if (org.gradle.internal.os.OperatingSystem.current().isWindows())
		return "windows"
	throw new GradleException("Unsupported host OS")
}

def getHostArch() {
	def arch = System.getProperty("os.arch")
	switch (arch) {
		case ["x86_64", "amd64"]:
			return "x86_64"
		case ~/^i[3456]86/:
		case "x86":
			return "x86"
		default:
			throw new GradleException("Can't detect host's CPU architecture: '${arch}'")
	}
}

def getHostTag() {
	def tag = getHostOS()
	def arch = getHostArch()
	if (tag != "windows" || arch != "x86")
		tag += "-${arch}"
	return tag
}

def getPrebuiltDir(abi) {
	def ndk = getNdkDir()
	def toolchainName = getToolchainName(abi)
	def toolchainPrefix = getToolchainPrefix(abi)
	def hostTag = getHostTag()
	def prebuiltDir = "${ndk}/toolchains/${toolchainName}-4.9/prebuilt/${hostTag}"
	return prebuiltDir
}

def getPlatformDir(abi) {
	def ndk = getNdkDir()
	def platformName = getPlatformName(abi)
	def platformDir = "${ndk}/platforms/android-23/${platformName}"
	return platformDir
}

// --------------------------------------------------------------------------------------------------------------------------------------------------
// This stuff processes the autotools config.h file and extracts all the macro definitions that decide what config said should get compiled or set.
// Here we turn each into a System.property.

import org.apache.tools.ant.types.Commandline
import org.eclipse.cdt.core.dom.ast.IASTPreprocessorMacroDefinition;
import org.eclipse.cdt.core.dom.ast.IASTPreprocessorStatement
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit
import org.eclipse.cdt.core.dom.ast.gnu.cpp.GPPLanguage
import org.eclipse.cdt.core.parser.*

def setPropsFromConfigH(abiType) {
	logger.info("************************************************************************")
	logger.info("Config.h grok begin")

	if (!file("../../ffmpeg/build_${abiType}/config.h").exists()) {
		logger.info("File: ../../ffmpeg/build_${abiType}/config.h does not exist")
	} else {
		FileContent fileContent = FileContent.createForExternalFileLocation("../ffmpeg/build_${abiType}/config.h")
		Map definedSymbols = new HashMap();
		String[] includePaths = new String[0];
		IScannerInfo info = new ScannerInfo(definedSymbols, includePaths);
		IParserLogService log = new DefaultLogService();
		int opts = 8;
		IncludeFileContentProvider emptyIncludes = IncludeFileContentProvider.getEmptyFilesProvider();

		IASTTranslationUnit translationUnit = GPPLanguage.getDefault().getASTTranslationUnit(fileContent, info, emptyIncludes, null, opts, log);
		IASTPreprocessorStatement[] preprocessorStatements = translationUnit.getAllPreprocessorStatements();
		preprocessorStatements.findAll { it instanceof IASTPreprocessorMacroDefinition }.each { IASTPreprocessorMacroDefinition macro ->
			if (macro.getExpansion().equals("0") || macro.getExpansion().equals("1")) {
				logger.debug("Set system property name: " + macro.getName() + " expansion: " + macro.getExpansion())
				System.setProperty(macro.getName().toString(), macro.getExpansion())
			}
		}
	}
//		each { statement ->
//		if (statement.class.equals(ASTMacroDefinition.class)) {
//			logger.info("Statement: " + statement + " class: " + statement.class)
//		}
//	}
	logger.info("Config.h grok end")
	logger.info("************************************************************************")
}

buildscript {
	dependencies {
		classpath files('build.lib/org.eclipse.cdt.core_6.0.0.201606062011.jar')
		classpath files('build.lib/org.eclipse.equinox.common_3.8.0.v20160509-1230.jar')
		classpath files('build.lib/org.eclipse.core.resources_3.11.0.v20160503-1608.jar')
		classpath files('build.lib/org.eclipse.core.runtime_3.12.0.v20160606-1342.jar')
		classpath files('build.lib/org.eclipse.core.jobs_3.8.0.v20160509-0411.jar')
		classpath files('build.lib/org.eclipse.core.jobs_3.8.0.v20160509-0411.jar')
		classpath files('build.lib/org.eclipse.core.contenttype_3.5.100.v20160418-1621.jar')
	}
}

ext {
	createConfigureTask = this.&createConfigureTask
	createSetupSourcesTask = this.&createSetupSourcesTask
	extractSourcesFromMakefile = this.&extractSourcesFromMakefile
	getPlatformDir = this.&getPlatformDir
}

dependencies {
	compile 'com.android.support:appcompat-v7:24.1.1'
	compile 'org.apache.ant:ant:1.8.0'
}